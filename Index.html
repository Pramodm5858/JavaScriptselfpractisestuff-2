<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScriptselfpractisestuff-2</title>
    <link rel="stylesheet" href="Style.css">
    <script type="text/javascript" src="Script.js"></script>
</head>
<body>
    
    <h1>Class 5 - javaScript</h1>
    <h1>javaScript ES6</h1>
    <p>The javaScript ES6 (also called ECMAScript 2015) defines a new set of rules governing the syntax of JS code </p>
    <p>1=> Let and Const keywords > Used to create block level variables 2=> Arrow functions > It reduces the length of the code for creating a function 3=>Classes > These are the templetes to create objects 4=>Default parameter values > It allows to pass the argument through a function by default 5=> find() and findIndex method > It helps to find the element or index of an array 6=> Exponentiation (**) > It raises the first operand to the power of the second operand</p>


    <h1>Templete String</h1>
    <p>new kind of string literally introduced in ES6. Strings are enclosed in backtick(``)instead of single or double quotes(",') eg `string ${expression} string text`</p>

    <h1>Functions in JS</h1>
    <p>1=> Regular Functions 2=> Arrow Functions 3=> Function Expression 4=> IFFE Functions 5=> Generator Funcitons</p>

    <h1>Regular Function</h1>
    <p>function myFunction(){
         var str = "Visit Edureka for bestonline courses";
         var pattern = /edureka/i;
         var result = str.match(pattern);
         document.write(result); 
    }
    myFunction();
    <p>JS makes use of following to identify pattern within strings:- Modifiers, Brackets, MetaCharaters, Quantifiers, RegExp Object methods, RegExp Object properties </p>    </p>

    <h1>Arrow Function</h1>
    <p>It reduce the length of syntax. There is no binding of 'this' keyword in these functions. In arrow function , "this" keywords always represents the object that defined the arrow function. If there is only one line of code, you can ignore brackets and return keyword of the function  </p>
    <p>
        myFunc = () => {
            var a =10; 
            var b =20;
            return ( a + b );
        }
        console.log(myFunc())
    </p>

    <h1>Function Expression</h1>
    <p>Function Expression are used to define a function inside an expression. The name of the function is ommitted. These function are always invoked with the help of variable name. Funciton expression must be declared before using them becz they aren't hoisted</p>
    <p>
        myFunc = function () {
            var a =10; 
            var b =20;
            return ( a + b );
        }
        console.log(myFunc())
    </p>

    <h1>IFFE Function</h1>
    <p>IFFE Funciton stands for Immediately Invoked Fnction Expression. These function used to create a function that can execute automatically after the function definition. It only runs once when the interpreter runs into it. IFFE function can be assigned to a varible to store its return value, not the function definition </p>
    <p>
        const display = (
            function () {
            var a ="Welcome to edureka"; 
            return a;
        }
        )();
        console.log(display)
    </p>


    <h1>Generator Function</h1>
    <p>Generator functions return generator object when called. these function are declared with "function" keyword by asterisk(*). These function doen't execute their body when called , insted the return an iternery object. Therefore iterator's next() method is used to execute the generators body. The next() method returns an object with two properties : value and done which indicates the yeilded value and whether the generator has yield its last value or not </p>
    <p>
        function* myGenerator() {

            var i = 0;
            for(i=0; i (lessthen) 10; i++){
                yield i;
            }
        }        
        const gen = myGenerator();

        for(i=0; i (lessthen) 10; i++){
            console.log(gen.next().value);
        }
        O/p:- 0123456789
    </p>

    <h1>Let keyword</h1>
    <p>ES6 provides a new way of declaring a variable by using the let keyword. Let keyword creates read & write reference to a value. It works similar to the var keyword. But the let keyword creates variables whose values can't be accessed outside the block.</p>

    <h1>Const keyword</h1>
    <p>ES6 provides a new way of declaring a constant by using the const keyword. Let keyword creates only read-only reference to a value. It works similar to the let keyword. But the const keyword creates block-scoped variables whose values can't be re-assigned.</p>

    <h1>Classes in JS </h1>
    <p>In Object oriented programming, a class is a blueprint for creating objects.</p>

    <p>
        class type_desserts {  <!-- Class Name -->
            constructor (type, prep){    <!-- Constructor method -->  <!-- parameters -->
                this.food_type=type;
                this.preparation=prep;
            }
        }        
        cupcake_bliss = new type_desserts("cakes", "bakes");                <!-- 'objects' of different restaurants -->
        Natural_ice_cream = new type_desserts("ice-cream", "freezed")       <!-- 'objects' of different restaurants -->
    </p>

    <h1>JS Object</h1>
    <p>An object is an instance of a class. It has states and behaviors. For Example: A dog has States - color, name and breed and Behaviors - wagging the tail, barking, eating.</p>

    <p ><!-- Syntax -->
        var person = new Objects();
        person.firstName = "John";
        person.lastName = "Doe";
        person.age = 50;
        person.eyeColor = "blue";
    </p>

    <h1>Constructor Method</h1>
    <p>The constructor method is a special method used to initialize properties. It is called automatically when an object of the class is instantiated, and it has to have exact name "constructor". If you do not have a constructor method, JS will add an invisible and empty constructor method. </p>
    
    <p ><!-- Syntax -->
        class class_name{
            constructor(brand){
                this.carname= brand;
            }
        }
    </p>

    <h1>This keyword</h1>
    <p>In JS, this keyword refers to the object it belongs to </p>
    <p>*=>It can have differet values depending on where it is used *=>if used in method, it refers to owner object *=> if used in Funciton, it refers to global object *=> if used in events, it refers to the element that received the event *=> if used alone, it will represent the global object *=> call() and apply() methods are predefined methods of JS *=>These methods can be used to call an object method with another object as argument</p>

    <h1>Import/Export Statements</h1>
    <p>In JS import Statements is used to import bindings that can be exported by another module or vice versa. It mmakes your code easily manageable. It makes debugging and understanding of your code simpler. You can export the code after writing it in one file so that it can be used by another file. </p>

    <h1>Introduction of Cookies</h1>
    <p>Cookies are small chunk of data. They can be used for authenticating, session tracking, remember specific information about the user like his name, password, last visited date etc </p>

    <p ><!-- Syntax -->
        funciton Write_Cookies(){
            cookievalue = "customer_name"
            document.cookie = "name=" + cookievalue;
            document.write ("Setting Cookies : " + "name=" + cookievalue);
        }
    </p>

    <p>Advatages of Cookies :- *=>Cookies are stored on the user's computer, so no extra burden on the server. *=>You can configure the cookies to expire when the brower session ends(session cookies), or they can exist for a specified length of time on the client's computer(persistent cookies). *=>The cookies are stored on clients hard disk, so if the server crashes, the cookies are still available.</p>

    <h1>Local Storage and Session Storage</h1>
    <p>methods -> setItem (key, value) = store key/value pair *=> getItem(key) *=> removeItem(key) *=> clear () *=> key (index) *=> length </p>

    <p>Local Storage vs Session Storage vs Cookies</p>
    <p>Max 5 MB to 10 MB storage  ||  Max 5MB storage || Max 4KB storage</p>
    <p>Only client side reading is supported || Only client side reading is supported || Supports both client side and server side reading</p>
    <p>The data stored is permanent, does not expire and remains stored on the user's computer untill a user/webapp asks the browser to delete it || Has a lifetime as the browser tab in which the data got stored.When the tab is closed, any data stored is deleted || We can set the expiration time for cookie by setting the 'expires' attribute to a date and time </p>
    <p>Stores data as JSON || Stores data as JSON || Stores data as String values </p>

    <h1>JS Ternery Operator</h1>
    <p>The ternery operator is  a conditional operator that is used as a shortcut for the if-statement. It takes 3 operands, a condition, a Statement to execute of the condition is met and a statement to execute of the condition is false. </p>

    <p >
        funciton getFee(isMenber){
            return (isMenber ? '$2.00' : '$10.00');
        }

        document.write(getFee(true)+ "<br>");   <!-- expected  O/p: "$2.00"  -->

        document.write(getFee(false)+ "<br>");   <!-- expected  O/p: "$10.00"  -->

        document.write(getFee(null)+ "<br>");   <!-- expected  O/p: "$10.00"  -->
    </p>


    <h1>Class 6 - javaScript </h1>
    <p>Topics -> *>JS Dictionary Object *> Callback Funcitons *>Promises *>Hoisting *>Event Handling *>Exception Handling *>Async/Await  in JS </p>

    <h1>JS Dictionary Object</h1>
    <p>Dictionary is a collection o key/value pairs. In JS, there is nothing as "Dictionary" type. However, we can store key value pairs as an object </p>

    <p>
        var dict = new Object();
        var dict = {}   <!--or the shorthand way  -->
        
        var dict = {FirstName: "Chris", one: "1", 1: "some value"}     
    </p>

    <p>
        var dict = {};

        dict["one"] = 1;   <!--using the Indexer  -->
        dict[1] = "one"; 

        dict["Age"]= 46;   <!--Add new or update property  -->

        dict.FirstName= "Chris";   <!--Direct property by name  -->

        document.write(dict.Age);
    </p>

    <h1>CallBack Funcitons</h1>
    <p>It is function that is passed as an argument to another function, which is later called in outer funciton  </p>
    <p>These functions are primarily used in JS to create asynchronous code</p>
    <p>JS executes the code in sequential top-down order, but in some cases, we need the code to run in a specific order. Callback functions are used to implement this, and it is known as asynchronous programming      </p>
    <p>The funciton that accepts other functions as arguments is known as a higher-order function, and it contains the logic for when the callback function get executed  </p>

    <h1>Promises</h1>
    <p>Promises help to handle asynchronous operations in JS. They are easy to manage when Handling multiple asynchronous operations where callbacks can create callback hell resulting in unmanagable code. A promise is an object which can be returned synchronously from an asynchronous function</p>

    <p>
        var promise = new Promise(function (resolve, reject){
        <!--do a thing possibly async, then...  -->
         if(<!--everything turned out fine -->){ 
                resolve("Stuff worked!");
            }
            else{
                reject(Error("It broke"));
            }
        });
    </p>

    <p>It have 3 possible states:- 1=> Fulfilled  2=>Rejected 3=>Pending</p>

    <h1>Hoisting</h1>
    <p>Hoisting is machanism of JS. It allows variables & functions to used before they are even declare. The declaration of variables and functions are moved to the top of the scope, before the execution. whether the scope or the declarations are global or local, they will always be moved to the top of their scope. initializations will not be hoisted on top    </p>

    <h1>Event Handling</h1>
    <p>When a user visits your website, they perform some activities such as clicking text, images, links, hover over elements etc. These are the e.g. of what JS calls events.</p>
    <p>Attribute :=> onload, onunload, onsubmit, onkeydown, onkeypress, onkeyup, onclick, ondblclick </p>

    <p>
    <!--head  -->
        <!--script  -->
        function over_div(){
            document.write("Mouse over the division ")
        }
        function out_div(){
            document.write("Mouse out of the division ")
        }
    <!--head  -->
    <p>Bring your mouse inside the division to see the result: </p>
        < div onmousemove="over_div()" onmouseout="out_div()" > 
            <h2>This is the division region</h2>
        < / div >
    </p>


    <h1>Scheduling a Call</h1>
    <p>When you don't want a function to execute Immediately on function call, but after predefined time interval on function call, it is called "Scheduling a call."</p>
    <p>There are 2 methods/ways to schdule a call 1=> setTimeOut(): Allows us to run a function once after the interval of time specified 2=> setInterval(): Allows us to run a function repeatedly, starting after the interval of time, then repeating continuously at that interval. </p>

    <h1>setTimeOut</h1>
    <p> <!--Syntax   -->
        var timer = setTimeout(func|code, [delay], [arg1], [arg2], ... );

        func|code : Function/string of code to execute (usually a function)

        delay: The delay before the run (in milliseconds) (1000 ms = 1second), by default 0.

        arg1, arg2... : Arguments for the function 
        
        function greeting (phrase, name){
            alert (phrase + ' , ' + name)
        }
        setTimeOut (greeting, 5000, "Hello", 'John')
    </p>

    <h1>setInterval</h1>
    <p> <!--Syntax   -->
        var timerId = setInterval(func|code, [delay], [arg1], [arg2], ... );

        func|code : Function/string of code to execute (usually a function)

        delay: The fixed interval between each successive run, in milliseconds (1000 ms = 1second), by default 0.

        arg1, arg2... : Arguments for the function 
        
        function greeting (phrase, name){
            alert (phrase + ',' + name)
        }
        setInterval (greeting, 5000, "Hello", 'John')
    </p>

    <h1>Exception Handling</h1>
    <p>JS programs may encounter errors/exceptions becz of mistakes , an unexpected user input, an erroneous server response, and for thousand other reasons. usually, a script "dies" (Immediately stops) in case of an error, printing it to console. To combat this, and prevent the error from stopping the entire flow of the script, JS provides a mechanism for error/exception Handling</p>
    <p>Type of error => 1)syntax 2)Logical 3)Runtime</p>

    <h1>Syntax Errors</h1>
    <p>Syntax error are generally caused by misspellings or bad punctuation. They are also called parsing errors, and occur at interpreting time in JS. Only the code contained within the same thread as the error is affected, and the rest of the code in other threads get executed (assuming nothing in them depends on the code containing the error).</p>

    <p><!-- example -->
        <!--script  -->
            document,write("This is an example to syntax error");
        <!--script  -->
    </p>

    <h1>RunTime Errors</h1>
    <p>RunTime errors are those that occur during execution (i.e., after completion/ interpretion). They are also called exceptions. Exceptions also affect only the thread in which they occur, allowing other JS threads to continue normal execution.</p>

    <p><!-- example -->
        <!--script  -->
            document.printme();<!--function printme() does not exist,,throwing error at runtime  -->
        <!--script  -->
    </p>

    <h1>Logical Errors</h1>
    <p>Logical error occur when you make a mistake in the logic that drives your script, and you do not get the result you expected. You cannot catch those errors, becz it depends on your business requirement what type of logic you want to put in your program.</p>

    <p><!-- example -->
        <!--script  -->
        var a =5;
        var b= 4;
        document.write("The product is " (a-b));<!--the O/p is expected is 20, but it returns 1, due to writing --><!--// (minus) - sign instead of * -->
        <!--script  -->
    </p>


    <h1>Try, catch, and finally Statements</h1>
    <p>The latest versions of JS added exception Handling capabilities. JS implements the try, catch, finally construct to handle exceptions.  </p>
    <p>try block:- The section of the code where an error is expected is placed within this block</p>
    <p>catch block:- The catch block follows the try block. It contains the set of operations to be performed if an error is thrown from the try block. You can catch programmer-generated and run-time exceptions, but you cannot catch syntax errors. </p>
    <p>finally block:- This is the block that will always execute unconditionally after the try/catch. It is optional to include this block.</p>

    <p>The try block must be followed by either exactly one catch block or one finally block (or one of both)</p>   
    <p>When an exception occurs in the try block, the exception is placed in e and the catch block is executed.</p>

    <p>
        <!--script  -->
        try{
            <!--code to run  -->
        }
        catch(e){
            <!--code to run if an exception occurs -->
        }
        finally{
            <!--code to run irrespective of whether an exception occurs -->
        }
    </p>

    <h1>Async/ Await in JS </h1>
    <p>"Async/await" is a special syntax to work with promises in a more comfortable fashion. It is easy to understand and use.   </p>

    <p>
        1) Async Functions: The async keyword can be placed before a function, like this:  
        <p>
            <!--script  -->
           async function f(){
            return 1;
           }
            <!--script  -->
        </p>
    </p>

    <p>
        <!--script  -->
       async function f(){           <!--The word "async" before a function means one simple thing: a function always returns a promise. Other values are wrapped in a resolved promise automatically. For instance, this function returns a resolved promise with the result '1'.     -->
        return 1;
       }

       f().then(alert)
        <!--script  -->
    </p>

    <p>
        <!--script  -->
       async function f(){           <!--  So sync ensures that the function returns a promise, and wrops non-promises in it. There's is another keyword, await, that works only inside async functions.        -->
        let promise = new Promise((resolve, reject)    <!--The keyword await makes JS wait until that promise settles and returns its result. Here's is an example with promise that resolves in 1 second.    -->
        => {                                            <!--The function execution "pauses" at the line (*) and resumes when the promise settles, with result becoming its result. So the code above(this) shows "done!" in one second.   -->
            setTimeOut(()=> resolve("done!"),1000 )
        })

        let result = await promise; <!--wait until the promise resolves     -->
        alert(result); 
       }

       f();
        <!--script  -->
    </p>
















</body>
</html>